function transformed_row = process_frame(current_row, prev_row)
    % current_row and prev_row are assumed to be tables with the same structure
    % If prev_row is empty, use the current row values as the base.
    if isstruct(current_row)
        current_row = struct2table(current_row);
    end
    if isstruct(prev_row)
        prev_row = struct2table(prev_row);
    end
    % Extract values from the current row
    time = current_row.time;
    rotation_x = current_row.rotation_x;
    rotation_y = current_row.rotation_y;
    rotation_z = current_row.rotation_z;
    rotation_w = current_row.rotation_w;
    position_x = current_row.position_x;
    position_z = current_row.position_z;
    
    % Use previous row values if available
    if ~isempty(prev_row)
        prev_time = prev_row.time;
        prev_position_x = prev_row.position_x;
        prev_position_z = prev_row.position_z;
        % Compute velocity from previous and current rows
        velocity_x = (position_x - prev_position_x) / (time - prev_time);
        velocity_y = (position_z - prev_position_z) / (time - prev_time);
    else
        velocity_x = 0;
        velocity_y = 0;
    end

    % Compute quaternion derivative using a similar approach
    if ~isempty(prev_row)
        prev_rotation_x = prev_row.rotation_x;
        prev_rotation_y = prev_row.rotation_y;
        prev_rotation_z = prev_row.rotation_z;
        prev_rotation_w = prev_row.rotation_w;
        dt = time - prev_time;
        dq_x = (rotation_x - prev_rotation_x) / dt;
        dq_y = (rotation_y - prev_rotation_y) / dt;
        dq_z = (rotation_z - prev_rotation_z) / dt;
        dq_w = (rotation_w - prev_rotation_w) / dt;
    else
        dq_x = 0; dq_y = 0; dq_z = 0; dq_w = 0;
    end

    % Compute angular velocity (using simplified calculations for one sample)
    omega_x = 2 * (rotation_w * dq_x + rotation_x * dq_w);
    omega_y = 2 * (rotation_w * dq_y + rotation_y * dq_w);
    omega_z = 2 * (rotation_w * dq_z + rotation_z * dq_w);

    % Compute yaw angle (Î¸) and convert to degrees
    yaw_angle = atan2(2 * (rotation_w * rotation_z + rotation_x * rotation_y), ...
                      1 - 2 * (rotation_y^2 + rotation_z^2));
    yaw_angle_deg = rad2deg(yaw_angle);

    % Return the processed data in a table
    transformed_row = struct(...
    'position_x', position_x, ...
    'position_y', current_row.position_y, ...
    'position_z', position_z, ...
    'rotation_x', rotation_x, ...
    'rotation_y', rotation_y, ...
    'rotation_z', rotation_z, ...
    'rotation_w', rotation_w, ...
    'time', time, ...
    'velocity_x', velocity_x, ...
    'velocity_y', velocity_y, ...
    'dq_x', dq_x, ...
    'dq_y', dq_y, ...
    'dq_z', dq_z, ...
    'dq_w', dq_w, ...
    'omega_x', omega_x, ...
    'omega_y', omega_y, ...
    'omega_z', omega_z, ...
    'yaw_angle_deg', yaw_angle_deg);

end

%%
function transformed_row = process_frame(current_row, prev_output)
    % Define machine centers (x, z)
    machine_centers = [
        1, 1;   % Machine 1
        2, 2;   % Machine 2
        3, 3;   % Machine 3
        4, 4    % Machine 4
    ];

    % Convert struct to table if needed
    if isstruct(current_row)
        current_row = struct2table(current_row);
    end
    if isstruct(prev_output)
        prev_output = struct2table(prev_output);
    end

    % Extract current values
    time = current_row.time;
    position_x = current_row.position_x;
    position_y = current_row.position_y;
    position_z = current_row.position_z;
    rotation_x = current_row.rotation_x;
    rotation_y = current_row.rotation_y;
    rotation_z = current_row.rotation_z;
    rotation_w = current_row.rotation_w;

    % Initialize default values
    velocity_x = 0; acceleration_x = 0;
    velocity_z = 0; acceleration_z = 0;
    theta_dot = 0; theta_dot_dot = 0;

    % Compute yaw angle (theta)
    theta = rad2deg(atan2(2 * (rotation_w * rotation_z + rotation_x * rotation_y), ...
                          1 - 2 * (rotation_y^2 + rotation_z^2)));

    % Compute velocities and accelerations if previous frame exists
    if ~isempty(prev_output)
        dt = time - prev_output.time;

        velocity_x = (position_x - prev_output.position_x) / dt;
        velocity_z = (position_z - prev_output.position_z) / dt;
        acceleration_x = (velocity_x - prev_output.velocity_x) / dt;
        acceleration_z = (velocity_z - prev_output.velocity_z) / dt;

        theta_dot = (theta - prev_output.theta) / dt;
        if isfield(prev_output, 'theta_dot')
            theta_dot_dot = (theta_dot - prev_output.theta_dot) / dt;
        end
    end

    % Compute theta_1 to theta_4 (angle between yaw direction and machine vector)
    theta_vec = [cosd(theta), sind(theta)];
    theta_n = zeros(1, 4);

    for i = 1:4
        dx = machine_centers(i, 1) - position_x;
        dz = machine_centers(i, 2) - position_z;
        machine_vec = [dx, dz];
        norm_product = norm(theta_vec) * norm(machine_vec);
        if norm_product > 0
            angle_rad = acos(dot(theta_vec, machine_vec) / norm_product);
            theta_n(i) = rad2deg(angle_rad);
        else
            theta_n(i) = 0;
        end
    end

    % Return all processed values
    transformed_row = struct(...
        'time', time, ...
        'position_x', position_x, ...
        'position_y', position_y, ...
        'position_z', position_z, ...
        'rotation_x', rotation_x, ...
        'rotation_y', rotation_y, ...
        'rotation_z', rotation_z, ...
        'rotation_w', rotation_w, ...
        'velocity_x', velocity_x, ...
        'acceleration_x', acceleration_x, ...
        'velocity_z', velocity_z, ...
        'acceleration_z', acceleration_z, ...
        'theta', theta, ...
        'theta_dot', theta_dot, ...
        'theta_dot_dot', theta_dot_dot, ...
        'theta_1', theta_n(1), ...
        'theta_2', theta_n(2), ...
        'theta_3', theta_n(3), ...
        'theta_4', theta_n(4) ...
    );
end
